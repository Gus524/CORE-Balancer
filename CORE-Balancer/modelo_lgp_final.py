# -*- coding: utf-8 -*-
"""Modelo LGP Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1We9mUInwQqyDz37A1U3eAHoyIkTjSbx8

## Descripción general.

1.   Elemento de lista
2.   Elemento de lista



Se tienen tres productos:

* 21A
* 22B
* 23C

Los ciclos de producción se manejan en cuatro **cuartiles** (Qn). Estos tienen una duración de 13 semanas (a excepción del cuartil Q4 96). Se cuenta con datos históricos de dos cuartiles anteriores (Q3 y Q4 del periodo 95).

Los cuartiles se denotan de la siguiente manera:

$$
Qn \space A
$$

Donde:
* $n$ es el número de cuartil, entre 1 y 4. $n \in \{1, 2, 3, 4\}$
* $A$ es el año al que pertenece el cuartil

Se cuenta con una planeación de diecisiéte (17) cuartiles (Q1 96 - Q1 00).

## Producción y demanda

En la planeación se muestra producción y la demanda, con los siguientes datos relevantes:

* $Y$ (_Yielded Supply_): Es la cantidad de un producto fabrica en un cuartil dado.
* $SST$ (_Safety Stock Target_): La cantidad mínima de artículos de un producto que se deben de mantener en invetario.
* $SSTW$ (_Safety Stock Target in Weeks of Service_): La cantidad de semanas de demanda que se pretenden satisfacer con el $SST$.
* $ED$ (_Efective Demand_): La cantidad solicitada de un producto para un cuartil específico.
* $T$ (_Total Projected Inventory Balance_): Cantidad de sobrantes o faltantes en inventario tomando en cuenta el stock al inicio del cuartil mas la producción ($Y$) del cuartil, restándole la demanda del cuartil.
* $TE$ (_Inventory Balance in Excess of SST_): El balance de inventario retirando el stock mínimo de seguridad ($SST$).

Para su cálculo semanal, la demanda efectiva ($ED$) cuenta con la siguiente tabla:

| Semana 1  | Semana 2  | Semana 3  | Semana 4  | Semana 5  | Semana 6  | Semana 7  | Semana 8  | Semana 9  | Semana 10 | Semana 11 | Semana 12 | Semana 13 |
|------|------|------|------|------|------|------|------|------|------|------|------|------|
| 5.50%| 5.50%| 5.50%| 5.50%| 5.50%| 5.50%| 5.50%| 5.50%| 6.00%| 10%  | 10%  | 15%  | 15%  |

Indicando qué porcentaje de la demanda efectiva se asigana a cada una de las semanas.

Es decir:

* $EDW\%$ (_Weekly Demand Ratio_): La cantidad porcentual de la demanda asignada a una semana específica.
> Esta tasa aplica para todos los tipos de producto.

## Fabricación
Así mismo se muestra la siguiente información respecto al proceso productivo:

Para la producción de cada uno de los productos se utilizan obleas de silicio como materia prima.

> El proceso productivo se realiza semanalmente.

* $dw$ (_Density per Wafer_): La cantidad de productos de un determinado modelo que se pueden obtener a partir de una oblea de silicio (_silicon **wafer**_).
* $AC$ (_Available Capacity_): Cantidad disponible de obleas para la fabricación de un producto durante una semana de un cuartil.
> Se tienen capacidad total y capacidad por producto. La capacidad individual es movible siempre y cuando no exceda la capacidad total.
* $Y\%$ (_Yield %_): Cantidad porcentual de productos aptos para venta obtenidos de cada proceso productivo.
> Es decir, de la cantidad de productos obtenidos de todas las obleas asignadas a la producción de un modelo de producto.

## Problema a resolver

Se busca realizar una planeación de asignación **semanal** de obleas a cada producto de tal manera que por lo menos se satisfaga la demanda pronosticada. Esta planeación se debe realizar de tal manera que el balance de inventario en exceso de $SST$ ($TE$) se mantenga entre 70M y 140M (setenta y ciento cuarenta millones) en los cuartiles intermedios (Q1 96 - Q4 99) y para el último cuartil (Q1 00) este balance debe ser 0.

### Políticas de la empresa a cumplir

Esta satisfacción se debe realizar de manera prioritaria, es decir:

1. Se busca por lo menos satisfacer la demanda del producto 21A.
2. Después, intentar satisfacer la demanda del producto 22B.
3. Finalmente, intentar satisfacer la demanda del producto 23C.

* Para el aumento gradual de producción (_ramp up_), solo se permite aumentar la asignación de obleas en hasta 560 obleas de una semana a la otra.
* La reducción gradual de producción (_ramp down_) no tiene restricciones.
* La cantidad de obleas asignadas debe ser un múltiplo de 5.

### Escenarios

Se tienen dos tipos de conjuntos de escenarios.

#### Escenarios de inventario inicial

* Inventario inicial en 0.
* Inventario inicial _real_ (obtenido de los datos provistos).
* Inventario inicial óptimo.

#### Escenearios de inventario final

* Balance de inventario final en 0.
* Balance de inventario final dentro del rango dado (70M - 140M)
* Balance de inventario final dentro de un rango personalizado.

---

## Obtención de datos

Notamos que se tendrán $i$ modelos de producto.
Se tienen $q$ cuartiles de $s$ semanas cada uno.

Modelos de producto:
$$
i \in \{21A,\space22B,\space23C\}
$$

### Datos fijos.

* $SSTW_i$: Cantidad en semanas de demanda que se deben cumplir para el producto $i$.
* $ED_{i, q}$: Demanda efectiva del producto $i$ para el cuartil $q$.
* $dw_i$: Cantidad de productos del modelo $i$ que se pueden obtener a partir de una oblea.
* $ACT_{q, s}$: Capacidad de obleas disponibles totales para el cuartil $q$ en la semana $s$.
* $AC_{i, q, s}$: Capacidad de obleas disponibles para la fabricación del producto $i$ en el cuartil $q$ para la semana $s$.
* $Y\%_{i, q, s}$: Tasa de éxito de fabricaciíon del producto $i$ en el cuartil $q$ durante la semana $s$.

### Datos calculados.

* $Y_{i, q, s}$:

$$
Y_{i, q, s} = dw_{i, q, s} \space ̇  \space w_{i, q, s} \space \dot \space \space Y\%_{i, q, s}
$$

Donde $w_{i, q, s}$ es la cantidad de obleas asignadas para la fabricación del producto $i$ para el cuartil $q$ en la semana $s$.

Además:

* $Y_{i, q} = \sum_{s = 1}^{m} Y_{i, q, s}$

Donde $m$ es la cantidad de semanas del cuartil $q$.

* $SST_{i, q}$:

$$
SST_{i, q} = \frac{ED_{i, q + 1} }{13} \dot \space SSTW_{i, q}
$$

* $T_{i, q}$:

$$
T_{i, q} = T_{i, q-1} + Y_{i, q} - ED_{i, q}
$$

* $TE_{i, q}$:

$$
TE_{i, q} = T_{i, q-1} + Y_{i, q} - ED_{i, q} - SST_{i, q}
$$

#### Datos calculados semanales

* $ED_{i, q, s}$:

$$
ED_{i, q, s} = ED_{i, q} \cdot EDW\%_{s}
$$

* $T_{i, q, s}$:

$$
T_{i, q, s} = T_{i, q, s-1} + Y_{i, q, s} - ED_{i, q, s}
$$

Más aún:

$$
TE_{i, q, s} = \sum_{s = 1}^{m}T_{i, q, s} - SST_{i, q}
$$

---

### Restricciones

* Ramp up:
 $$ 0 \leq w_{i, q, s} - w_{i, q, s-1} \leq 560 $$

* Cantidad total de obleas asignadas:
$$\sum_{i = 21A}^{23C} w_{i, q, s} = 5k : k \in \mathbb{Z}^+$$

* Capacidad de obleas:

$$ \sum_{i = 21A}^{23C} w_{i, q, s} \leq ACT_{q, s} $$

* Mininmo de obleas por semana:

$$ W_{i,q,s} \geq 350$$

* Balance de inventario:
  * Caso de inventario final en 0:

    Si $q \neq Q1\space00$:

$$  
70 \cdot 10^6 \leq TE_{q, s} \leq 140 \cdot 10^6
$$
    En otro caso:  
$$
TE_{q,s} = 0
$$
* Caso de inventario final en el rango dado:
$$  
70 \cdot 10^6 \leq TE_{q, s} \leq 140 \cdot 10^6, \space ∀ \space q
$$

* Caso de inventario final en un rango personalizado:

Para $q = Q1\space 00$
$$  
x \leq TE_{q, s} \leq y, \space ∀ \space q
$$

Donde $x$ y $y$ son los límites inferior y superior, respectivamente.

Tales que:

$ x, y \in \mathbb{Z}^+ $

$x < y$
"""

import pulp

"""## Solución.

Se propone un modelo de **Programación por Metas Lexicográfico**.

### Definición de Conjuntos e Índices:

* Productos ($i$): $I = \{\space 21A,22B,23C \space\}$

* Cuartiles ($q$): $Q =\{\space Q1 \space 96, Q2 \space 96, ..., Q4 \space 99, Q1 \space 00 \space\}$

  Y sea $N_Q = 17$ el número total de cuartiles. Indexamos q de $1$ a $N_Q$.
  $Q_{intermedios} = \{1, ...,N_Q - 1\}$
  $Q_{final} = \{N_Q\}$

* Semanas ($s$): $S_q = \{1, 2, ..., m_q\}$, donde $m_q$ es el número de semanas en el cuartil $q$. Generalmente $m_q = 13$. Para el caso en el que $q = Q4 \space 96$, se tomará $m_q = 14$.

  Sea $W$ el conjunto de todos los pares $(q, s)$ ordenados cronológicamente.
  $W_{total} = \sum_{q=1}^{N_q}m_q$.

* Tiempo (semanal continuo) ($t$): Podemos mapear cada $(q, s)$ a un índice de tiempo único $t \in \{1, ..., W_{total}\}$.
  
  Es decir: $t(s, q) = (\sum_{k=1}^{q-1}m_k) + s$.

  Si $t = 0$, entonces tomaremos la última semana del periodo histórico.

2. Parámetros:

  * $ED_{i,q}$: Demanda efectiva del producto i en el cuartil q.
  * $EDW\%_s$: Porcentaje de damnda semanal para la semana s.
    
  > Si $q = 4$ entonces:
  >
  > $EDW\%_1= 2.25\%, \space EDW\%_2 = 2.25\%$

  * $dw_i$: Densidad (productos por oblea) para el producto $i$

  * $Y\%_i$: Porcentaje de rendimiento para el producto $i$.

  * $SSTW_i$: Objetivo de stock de seguridad en semanas de servicio para el producto $i$.

  * ACT_{q, s}: Capacidad total de obleas disponibles en la semana $s$ del cuartil $q$.

  * $T_{i,0}$: Inventario incial del producto $i$ al comienzo de $Q1 \space 96$

  * $w_{i, 0}$: Asignación de obleas la producto $i$ en la última semana de $Q4 \space 95$. Si es deconocido, se asume igual a 0.

  * $RUpMax = 560$: Límite máximo de incremento semanal de uso de obleas.

  * $TE_{min} = 70 \cdot 10^6$: Límite inferior para $TE$ en cuartiles intermedios.

  * $TE_{max} = 140 \cdot 10^6$: Límite inferior para $TE$ en cuartiles intermedios.

  * ${x, y}$: Rango personalizado para $TE$ en el cuartil final (escenario específico).

  * $m_q = 13$: Número de semanas por cuartil. Si $q = 4$, $m_4 = 14$

3. Cálculos Preliminares:

  * Demanda Semanal Efectiva: $ED_{i, q, s} = ED_{i, q} \cdot EDW\%_{s}$

  * Objetivo de Stock de Seguridad para un Cuartil:
  $SST_{i,q} = (\frac{ED_{i,q+}}{m_{q+1}}) \cdot SST_i$.
  La demanda para el cuartil siguiente al término del periodo total se obtendrá por un pronóstico.

4. Variables de Decisión:

  * $k_{i, q, s}$: Variable auxiliar que representa la cantidad de lotes 5 obleas para el producto $i$ en la semana $s$ del cuartil $q$.
  $k_{i, q, s} \in \mathbb{Z}^+$

  * $w_{i, q, s}$: Cantidad de obleas asignadas para la producción del artículo $i$ en la semana $s$ del cuartil $q$.
  $w_{i, q, s} = 5 \cdot k_{i, q, s}$.

5. Variables Auxiliares:

  * $Y_{i, q, s}$: Producción del producto $i$ en la semana $s$ del cuartil $q$.
  $Y_{i, q, s} = dw_{i} \cdot w_{i, q, s} \cdot Y\%{i}$

  * $T{i, q, s}$_ Inventario Proyectado Total del producto $i$ al final de la semana $s$ del cuartil $q$.
  $T_{i, q, s} = T{i, q, s-1} + Y_{i, q, s} - ED_{i, q, s}$.
  Donde $T_{i, q, 0} = T_{i, q-1, m_{q-1}}$ para $q > 1$ y $T_{i, 1, 0} = T_{i, 0}$, es decir, el inventario inicial dado por el esceneario.

  * $TE_q$: Balance de Inventario en Exceso de SST al final del cuartil $q$.
  $TE_{q} = \sum_{i \in I}(T_{i, q, m_q} - SST_{i, q})$

6. Variables de Desviación:

  * $d^-_{T,i,q,s}$: Faltante de inventario para el producto i al final de la semana $s$ del cuartil $q$. Este nos indicará la demanda semanal __no satisfecha__ en dicho periodo.

  * $d^-_{TE,q}$: Cantidad en que $TE_q$ está por debajo del límite inferior del rango objetivo para el cuartil $q$.

  * $d^+_{TE,q}$: Cantidad en que $TE_q$ está por encima del límite superior del rango objetivo para el cuartil $q$.

7. Restricciones:

  * Balance de inventario semanal:
  Para todos los $i \in I, q \in Q, s \in S_q$:
  $T_{i, q, s} + T_{i, q, s-1} = dw_i \cdot (5k_{i, q, s}) \cdot Y\%_i - ED_{i, q, s}$.
  Es decir: El balance de inventario de la semana actual y la anterior del cuartil $q$ debe ser igual a la producción del producto $i$ de la semana $s$ del cuartil $q$.

  * Capacidad Total de obleas:
  Para todos los $q \in Q, s \in S_q$:
  $\sum_{i \in I}5k_{i, q, s} \leq ACT_{q, s}$

  * Ramp-up:
  Para todo $i \in I$ y para todo par $(q, s)$ a partir de la segunda semana del cuartil $Q1 \space 96$:
  $5k_{i, q, s} - 5k_{i, q, s-1} \leq RUpMax$.
  Para la primer semana a partir del segundo cuartil, es decir, para $s = 1, q > 1$:
  $5k_{i, q, 1} - 5k_{1, q-1, m_{q-1}} \leq RUMax$
  Por otro lado, para la primer semana del primer cuartil, es decir, para $s = 1, q = 1$:
  $5_k{i, 1, 1} - w_{i, 0} \leq RUpMax$

* No negatividad y garantía de variables enteras:

  * $k_{i, q, s} \in \mathbb{Z}^+$
  * $T_{i, q, s} \in \mathbb{Z}$
  * $d^-_{T, i, q, s}, \space d^-_{TE, q} \space d^+_{TE, q} \in \mathbb{Z}^+ $

8. Metas y funciones objetivo:

Para el funcionamiento del modelo de Programación por Metas Lexicográfico se plantean las siguientes metas, ordenadas en prioridad:

  * Meta 1 ($P_1$):
  Satisfacer demanda semanal del producto 21A:
    * Restricción para la meta:
    $T_{21A, q, s} + d^-_{T, 21A, q, s} \geq 0$ para todo $q \in Q, s \in S_q$.
    * Función objetivo $P_1$:

    minimizar $\space P_1 = \sum_{q \in Q} \sum_{s\in S_q}d^-_{T, i, q, s}$
  
  * Meta 2 ($P_2$):
  Satisfacer demanda semanal del producto 22B:

    * Restricción para la meta:
    $T_{22B, q, s} + d^-_{T, 22B, q, s} \geq 0$ para todo $q \in Q, s \in S_q$.
    * Función objetivo $P_2$:

    minimizar $\space P_1 = \sum_{q \in Q} \sum_{s\in S_q}d^-_{T, i, q, s}$

  * Meta 3 ($P_3$):
    Satisfacer demanda semanal del producto 23C:

    * Restricción para la meta:
    $T_{23C, q, s} + d^-_{T, 23C, q, s} \geq 0$ para todo $q \in Q, s \in S_q$.
    * Función objetivo $P_3$:

    minimizar $\space P_1 = \sum_{q \in Q} \sum_{s\in S_q}d^-_{T, i, q, s}$

  * Meta 4 ($P_4$):
    Mantener el balance total en exceso (TE_q) dentro de los rangos:
    * Para los cuartiles intermedios ($q \in Q_{intermedios}$):
$TE_q + d^-_{TE,q} \geq TE_{min}$
$TE_q + d^+_{TE,q} \geq TE_{max}$

      > Recordando que:
      > $TE_q = \sum_{i \in I}(T_{i, q, m_q - SST_{i, q}})$

    * Para el último cuartil ($q = N_Q$):
      * Escenario de inventario final en 0:
  $TE_{N_q} + d^-_{TE,q} - d^+_{TE,q} = 0$
      * Escenario de inventario fina en el intervalo $[70M, 140M]$
  $TE_{N_q} + d^-_{TE,q} - d^+_{TE,q} \geq TE_{min}$

  $TE_{N_q} + d^-_{TE,q} - d^+_{TE,q} \leq TE_{max}$

    * Función objetivo $P_4$:

  minimizar $P_4 = \sum_{q\in Q_{intermedios}}(d^-_{TE,q} -+d^+_{TE,q}) + (d^-_{N_q} -+d^+_{N_q})$

## Solución.

Por la caracterizticas especificas del problemas relacionadas con la priorización de algunas restricciones enfocadas en favorecer el cumpliemiento de la demanda de algunos productos sobre otros, nos hemos enfocadoe en realizar una implementación enfocada en el programación por metas, siedo esta es una extención de la programación lineal, nuestro enfoque sigue el metodo programación por metas lexicografica para asegurar el cumplimiento de cada una de las restricciones.

Nos hemos inclinado mas por este tipo de variante de la porgramacíon lineal debido a sus bondades y robustes a la hora de realziar soluciones, dejando pocos parameteros de olguras en las varibles, logrando gran precisón y fidelidad en los resultados.

Para plantear una función objetivos relacionada al Inventory Balance in excess of SST, hemos abstraido el manejo de las variables de la siguiente forma:

* Productos ($i$): $I = \{\space 21A,22B,23C \space\}$

* Cuartiles ($q$): $Q =\{\space Q1 \space 96, Q2 \space 96, ..., Q4 \space 99, Q1 \space 00 \space\}$

  Y sea $N_Q = 17$ el número total de cuartiles. Indexamos q de $1$ a $N_Q$.
  $Q_{intermedios} = \{1, ...,N_Q - 1\}$
  $Q_{final} = \{N_Q\}$

* Semanas ($s$): $S_q = \{1, 2, ..., m_q\}$, donde $m_q$ es el número de semanas en el cuartil $q$. Generalmente $m_q = 13$.
  * Pero para el caso en el que $q = Q4 \space 96$, se tomará $m_q = 14$.

  Sea $W$ el conjunto de todos los pares $(q, s)$ ordenados cronológicamente.
  $W_{total} = \sum_{q=1}^{N_q}m_q$.

* Tiempo (semanal continuo) ($t$): Podemos mapear cada $(q, s)$ a un índice de tiempo único $t \in \{1, ..., W_{total}\}$.
  
  Es decir: $t(s, q) = (\sum_{k=1}^{q-1}m_k) + s$.

  Si $t = 0$, entonces tomaremos la última semana del periodo histórico.

2. Parámetros:

  * $ED_{i,q}$: Demanda efectiva del producto i en el cuartil q.
  * $EDW\%_s$: Porcentaje de damnda semanal para la semana s.
    
  > Si $q = 4$ entonces:
  >
  > $EDW\%_1= 2.25\%, \space EDW\%_2 = 2.25\%$

  * $dw_i$: Densidad (productos por oblea) para el producto $i$

  * $Y\%_i$: Porcentaje de rendimiento para el producto $i$.

  * $SSTW_i$: Objetivo de stock de seguridad en semanas de servicio para el producto $i$.

  * $ACT_{q, s}$: Capacidad total de obleas disponibles en la semana $s$ del cuartil $q$.

  * $T_{i,0}$: Inventario incial del producto $i$ al comienzo de $Q1 \space 96$

  * $w_{i, 0}$: Asignación de obleas la producto $i$ en la última semana de $Q4 \space 95$. Si es deconocido, se asume igual a 0.

  * $RUpMax = 560$: Límite máximo de incremento semanal de uso de obleas.

  * $TE_{min} = 70 \cdot 10^6$: Límite inferior para $TE$ en cuartiles intermedios.

  * $TE_{max} = 140 \cdot 10^6$: Límite inferior para $TE$ en cuartiles intermedios.

  * ${x, y}$: Rango personalizado para $TE$ en el cuartil final (escenario específico).

  * $m_q = 13$: Número de semanas por cuartil. Si $q = 4$, $m_4 = 14$

3. Cálculos Preliminares:

  * Demanda Semanal Efectiva: $ED_{i, q, s} = ED_{i, q} \cdot EDW\%_{s}$

  * Objetivo de Stock de Seguridad para un Cuartil:
  $SST_{i,q} = (\frac{ED_{i,q+}}{m_{q+1}}) \cdot SST_i$.
  La demanda para el cuartil siguiente al término del periodo total se obtendrá por un pronóstico.

4. Variables de Decisión:

  * $k_{i, q, s}$: Variable auxiliar que representa la cantidad de lotes 5 obleas para el producto $i$ en la semana $s$ del cuartil $q$.
  $k_{i, q, s} \in \mathbb{Z}^+$

  * $w_{i, q, s}$: Cantidad de obleas asignadas para la producción del artículo $i$ en la semana $s$ del cuartil $q$.
  $w_{i, q, s} = 5 \cdot k_{i, q, s}$.

5. Variables Auxiliares:

  * $Y_{i, q, s}$: Producción del producto $i$ en la semana $s$ del cuartil $q$.
  $Y_{i, q, s} = dw_{i} \cdot w_{i, q, s} \cdot Y\%{i}$

  * $T{i, q, s}$_ Inventario Proyectado Total del producto $i$ al final de la semana $s$ del cuartil $q$.
  $T_{i, q, s} = T{i, q, s-1} + Y_{i, q, s} - ED_{i, q, s}$.
  Donde $T_{i, q, 0} = T_{i, q-1, m_{q-1}}$ para $q > 1$ y $T_{i, 1, 0} = T_{i, 0}$, es decir, el inventario inicial dado por el esceneario.

  * $TE_q$: Balance de Inventario en Exceso de SST al final del cuartil $q$.
  $TE_{q} = \sum_{i \in I}(T_{i, q, m_q} - SST_{i, q})$

6. Variables de Desviación:

  * $d^-_{T,i,q,s}$: Faltante de inventario para el producto i al final de la semana $s$ del cuartil $q$. Este nos indicará la demanda semanal __no satisfecha__ en dicho periodo.

  * $d^-_{TE,q}$: Cantidad en que $TE_q$ está por debajo del límite inferior del rango objetivo para el cuartil $q$.

  * $d^+_{TE,q}$: Cantidad en que $TE_q$ está por encima del límite superior del rango objetivo para el cuartil $q$.

7. Restricciones:

  * Balance de inventario semanal:
  Para todos los $i \in I, q \in Q, s \in S_q$:
  $T_{i, q, s} + T_{i, q, s-1} = dw_i \cdot (5k_{i, q, s}) \cdot Y\%_i - ED_{i, q, s}$.
  Es decir: El balance de inventario de la semana actual y la anterior del cuartil $q$ debe ser igual a la producción del producto $i$ de la semana $s$ del cuartil $q$.

  * Capacidad Total de obleas:
  Para todos los $q \in Q, s \in S_q$:
  $\sum_{i \in I}5k_{i, q, s} \leq ACT_{q, s}$

  * Ramp-up:
  Para todo $i \in I$ y para todo par $(q, s)$ a partir de la segunda semana del cuartil $Q1 \space 96$:
  $5k_{i, q, s} - 5k_{i, q, s-1} \leq RUpMax$.
  Para la primer semana a partir del segundo cuartil, es decir, para $s = 1, q > 1$:
  $5k_{i, q, 1} - 5k_{1, q-1, m_{q-1}} \leq RUMax$
  Por otro lado, para la primer semana del primer cuartil, es decir, para $s = 1, q = 1$:
  $5_k{i, 1, 1} - w_{i, 0} \leq RUpMax$

* No negatividad y garantía de variables enteras:

  * $k_{i, q, s} \in \mathbb{Z}^+$
  * $T_{i, q, s} \in \mathbb{Z}$
  * $d^-_{T, i, q, s}, \space d^-_{TE, q} \space d^+_{TE, q} \in \mathbb{Z}^+ $

8. Metas y funciones objetivo:

Para el funcionamiento del modelo de Programación por Metas Lexicográfico se plantean las siguientes metas, ordenadas en prioridad:

  * Meta 1 ($P_1$):
  Satisfacer demanda semanal del producto 21A:
    * Restricción para la meta:
    $T_{21A, q, s} + d^-_{T, 21A, q, s} \geq 0$ para todo $q \in Q, s \in S_q$.
    * Función objetivo $P_1$:

    minimizar $\space P_1 = \sum_{q \in Q} \sum_{s\in S_q}d^-_{T, i, q, s}$
  
  * Meta 2 ($P_2$):
  Satisfacer demanda semanal del producto 22B:

    * Restricción para la meta:
    $T_{22B, q, s} + d^-_{T, 22B, q, s} \geq 0$ para todo $q \in Q, s \in S_q$.
    * Función objetivo $P_2$:

    minimizar $\space P_1 = \sum_{q \in Q} \sum_{s\in S_q}d^-_{T, i, q, s}$

  * Meta 3 ($P_3$):
    Satisfacer demanda semanal del producto 23C:

    * Restricción para la meta:
    $T_{23C, q, s} + d^-_{T, 23C, q, s} \geq 0$ para todo $q \in Q, s \in S_q$.
    * Función objetivo $P_3$:

    minimizar $\space P_1 = \sum_{q \in Q} \sum_{s\in S_q}d^-_{T, i, q, s}$

  * Meta 4 ($P_4$):
    Mantener el balance total en exceso (TE_q) dentro de los rangos:
    * Para los cuartiles intermedios ($q \in Q_{intermedios}$):
$TE_q + d^-_{TE,q} \geq TE_{min}$
$TE_q + d^+_{TE,q} \geq TE_{max}$

      > Recordando que:
      > $TE_q = \sum_{i \in I}(T_{i, q, m_q - SST_{i, q}})$

    * Para el último cuartil ($q = N_Q$):
      * Escenario de inventario final en 0:
  $TE_{N_q} + d^-_{TE,q} - d^+_{TE,q} = 0$
      * Escenario de inventario fina en el intervalo $[70M, 140M]$
  $TE_{N_q} + d^-_{TE,q} - d^+_{TE,q} \geq TE_{min}$

  $TE_{N_q} + d^-_{TE,q} - d^+_{TE,q} \leq TE_{max}$

    * Función objetivo $P_4$:

  minimizar $P_4 = \sum_{q\in Q_{intermedios}}(d^-_{TE,q} -+d^+_{TE,q}) + (d^-_{N_q} -+d^+_{N_q})$

Algo muy importante en tomar en cuenta en la implementación es que aunque en principio se usa el solver pulp, la implementación esta pensada para poderce resolver con multipes solvers, ya sean de pago o de codigo abierto, ejemplos de estas pueden ser Gurobi o CPLEX.
"""

!pip install pulp

from google.colab import drive
drive.mount('/content/drive')

import pulp as plp
print(plp.listSolvers(onlyAvailable=True))

# Se importan las bibliotecas necesarias
import pulp as plp
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os # Para guardar archivos .lp
import time # Para medir el tiempo
from collections import defaultdict

# Para la hora local
try:
    from datetime import datetime
    import pytz # Necesitarás instalar pytz: pip install pytz
    # Asegúrate que la zona horaria sea correcta para Guadalajara
    TIMEZONE = 'America/Mexico_City'
except ImportError:
    pytz = None
    TIMEZONE = None
    print("Advertencia: pytz no instalado. La hora local no se mostrará con zona horaria.")
except Exception as e_tz_init:
    pytz = None
    TIMEZONE = None
    print(f"Advertencia: Error inicializando pytz ({e_tz_init}). La hora local no se mostrará con zona horaria.")

# Mostrar hora actual (opcional)
if pytz and TIMEZONE:
    try:
        tz_local = pytz.timezone(TIMEZONE)
        now_local = datetime.now(tz_local)
        print(f"Hora actual ({TIMEZONE}): {now_local.strftime('%Y-%m-%d %H:%M:%S %Z%z')}")
    except Exception as e_tz:
        print(f"Error al obtener hora local ({TIMEZONE}): {e_tz}")
else:
    print(f"Hora actual (Sistema): {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

print(f"PuLP version: {plp.__version__}")
print(f"Pandas version: {pd.__version__}")
print(f"NumPy version: {np.__version__}")

# Se tienen los siguientes parametros configurables
SOLVER_NAME = 'CBC' # Opciones: 'CBC', 'GLPK', 'SCIP', 'GUROBI', 'CPLEX', etc. Esto para la escalabilidad del modelo
# Ajusta el tiempo límite según sea necesario para segmentos más grandes
SOLVER_TIME_LIMIT_SECONDS_PER_GOAL = 900 # Límite tiempo (segundos) por cada meta LGP (por segmento)
SOLVER_MIP_GAP_RELATIVE = 0.05 # Tolerancia optimalidad (0.05 = 5%). 0 busca óptimo exacto. Entre más pequeño el modelo tardará más y incrementa la probabilidad de no encontrar optimos
SOLVER_THREADS = 8 # Hilos CPU (Normalmente son 8 en las computadoras y sona las que tienen 8 nucleos lógicos o 4 pcores)
FINAL_TE_TARGET_MODE = 'zero' # Meta TE último cuartil: 'zero' o 'range'
STANDARD_WEEKS_PER_QUARTILE = 13 # Define cuál es el número estándar de semanas (No incluye a cuartiles con más semandas esa se calculan)

# Parámetros específicos del problema/proceso
RUpMax = 560  # Límite Ramp-up (si se activa restricción), no debe haber incremenos graduales
TE_min = 70 * 10**6 # Límite inferior para TE (Inventario en Exceso)
TE_max = 140 * 10**6 # Límite superior para TE
Wmin_s = 350 # Mínimo de obleas a procesar por semana

print("Parámetros de configuración cargados.")
print(f"Solver seleccionado: {SOLVER_NAME}")
print(f"Límite de tiempo por meta: {SOLVER_TIME_LIMIT_SECONDS_PER_GOAL}s")

# Se tienen los siguientes datos de entrada del problema

productos = ['21A', '22B', '23C'] # i - productos

# Nombres de los cuartiles
quartiles_nombres = [
    "Q1-96", "Q2-96", "Q3-96", "Q4-96",
    "Q1-97", "Q2-97", "Q3-97", "Q4-97",
    "Q1-98", "Q2-98", "Q3-98", "Q4-98",
    "Q1-99", "Q2-99", "Q3-99", "Q4-99",
    "Q1-00"
] # Define N_Q = 17

ANOMALOUS_QUARTILE_NAME = "Q4-96" # Nombre exacto del cuartil con semanas anómalas
ANOMALOUS_QUARTILE_WEEKS = 14    # Número de semanas para ese cuartil anómalo

#Demandas pronosticadas por cuartil
demandas_pronosticadas_por_cuartil = {
    '21A': [3895110216, 3422192793, 7028084658, 2849951523, 944509749, 1485694254, 1470743573, 3022301940, 2314112358, 2151412653, 1963712436, 1920989711, 2744271015, 1477684393, 4483691039, 6942866279, 3513859960],
    '22B': [2312831674, 1241864059, 2660101592, 1588864169, 1479807074, 1332754328, 1183814463, 2956338712, 850295467, 217725116, 171775577, 120686980, 172409971, 92836138, 2029952952, 1198320556, 2392332570],
    '23C': [5867076911, 6276580638, 15055157034, 6225735537, 5118025634, 2789209292, 2116912411, 4940239551, 1496928136, 1476627975, 1518438181, 1133822021, 1472132049, 792686488, 9082305290, 4776372652, 8644776401]
}
# Verificar consistencia longitud demandas vs nombres para que no haya erroes en calculos posteriores
for p in productos:
     if len(demandas_pronosticadas_por_cuartil[p]) != len(quartiles_nombres):
         print(f"ADVERTENCIA: Longitud de demanda para {p} ({len(demandas_pronosticadas_por_cuartil[p])}) no coincide con número de cuartiles ({len(quartiles_nombres)})")

#Se necesita saber cuanta demanda por semana s edebe cumplir y se agrega la demanda que se debe cumplir en el cuartil anomalo
ratio_demanda_semanal_std = [0.055, 0.055, 0.055, 0.055, 0.055, 0.055, 0.055, 0.055, 0.06, 0.1, 0.1, 0.15, 0.15] # 13 semanas
ratio_demanda_semanal_anomalo = [0.055, 0.055, 0.055, 0.055, 0.055, 0.055, 0.038, 0.036, 0.036, 0.06, 0.1, 0.1, 0.15, 0.15] # 14 semanas

#Se crea una lista con la cantidad de productos por wifer de cada producto
densidad_por_producto = {'21A': 94500, '22B': 69300, '23C': 66850} # dw_i

# Calcula el número total máximo de semanas basado en los cuartiles definidos
MAX_HORIZONTE_TOTAL = sum(ANOMALOUS_QUARTILE_WEEKS if qn == ANOMALOUS_QUARTILE_NAME else STANDARD_WEEKS_PER_QUARTILE
                           for qn in quartiles_nombres)

# Asegurar que los arrays de rendimiento y capacidad cubran todo el horizonte posible
porcentaje_rendimiento_por_producto = {
    '21A': ([90.59] * MAX_HORIZONTE_TOTAL),
    '22B': ([90.85] * MAX_HORIZONTE_TOTAL),
    '23C': ([90.55] * MAX_HORIZONTE_TOTAL)
}
sstw_por_producto = {'21A': 1.82, '22B': 1.56, '23C': 1.42} # SSTW_i
capacidad_obleas_por_semana = ([12700] * MAX_HORIZONTE_TOTAL)

# Estados iniciales (al inicio de la primera iteración)
#Aqui se debe establecer los casos del inventario inicial!!!!!!!!!!!!!!!!!!
inventarios_iniciales_globales = {'21A': 0, '22B': 0, '23C': 0} # T_{i,0} GLOBAL
wafers_iniciales_t0_globales = {'21A': 0, '22B': 0, '23C': 0} # w_{i,0} GLOBAL (si se usara ramp-up)

print(f"Datos de entrada cargados. Productos: {productos}")
print(f"Número de cuartiles: {len(quartiles_nombres)}. Horizonte máx. estimado: {MAX_HORIZONTE_TOTAL} semanas.")
print(f"Inventarios iniciales globales: {inventarios_iniciales_globales}")

# Celda 4: Pre-cálculos Globales

print("Realizando pre-cálculos globales...")

# --- Índices y Mapeos ---
N_Q = len(quartiles_nombres) #son los cuartiles que tenemos Q96 1, Q96 2...
quartiles_idx = list(range(1, N_Q + 1)) # Índices numéricos q = 1..N_Q
q_idx_a_nombre = {i+1: name for i, name in enumerate(quartiles_nombres)} #Diccionaros de indices para encontar cuartiles más rápido.
nombre_a_q_idx = {name: i+1 for i, name in enumerate(quartiles_nombres)} # Inverso

# Mapear demandas a índices numéricos
demandas_por_indice = {p: {q_idx: demandas_pronosticadas_por_cuartil[p][i]
                            for i, q_idx in enumerate(quartiles_idx) if i < len(demandas_pronosticadas_por_cuartil[p])}
                           for p in productos}

# Identificar índice del cuartil anómalo
anomalous_q_idx = -1
if ANOMALOUS_QUARTILE_NAME in nombre_a_q_idx:
     anomalous_q_idx = nombre_a_q_idx[ANOMALOUS_QUARTILE_NAME]
     print(f"Cuartil anómalo '{ANOMALOUS_QUARTILE_NAME}' encontrado con índice: {anomalous_q_idx}")
else:
     print(f"ADVERTENCIA: Cuartil anómalo '{ANOMALOUS_QUARTILE_NAME}' no encontrado en la lista 'quartiles_nombres'. Se usará el número de semanas estándar para todos.")
     # Si no se encuentra, ANOMALOUS_QUARTILE_WEEKS no se usará efectivamente abajo

# Calcular semanas por cuartil basado en el anómalo
semanas_por_cuartil_dict = {q_idx: (ANOMALOUS_QUARTILE_WEEKS if q_idx == anomalous_q_idx else STANDARD_WEEKS_PER_QUARTILE)
                            for q_idx in quartiles_idx}
print(f"Semanas calculadas por cuartil (índice): {semanas_por_cuartil_dict}")

# Mapeo del timpo global
semanas_cuartil_local_a_global = {} # {(q_idx, s_local): t_global}
semana_global_a_cuartil_local = {} # {t_global: (q_idx, s_local)}
t_global_max_calculado = 0
t_global = 1
for q_idx in quartiles_idx:
    m_q = semanas_por_cuartil_dict[q_idx]
    for s_local in range(1, m_q + 1):
        semanas_cuartil_local_a_global[(q_idx, s_local)] = t_global
        semana_global_a_cuartil_local[t_global] = (q_idx, s_local)
        t_global += 1
t_global_max_calculado = t_global - 1
print(f"Mapeo de tiempo global creado hasta la semana: {t_global_max_calculado}")
if t_global_max_calculado != MAX_HORIZONTE_TOTAL:
     print(f"ADVERTENCIA: Mapeo global ({t_global_max_calculado}) no coincide con MAX_HORIZONTE_TOTAL ({MAX_HORIZONTE_TOTAL})")


# Calcular la demanda semanalmente
demandas_semanales = defaultdict(dict) # {prod: {t_global: demanda}}
for p in productos:
    for q_idx in quartiles_idx:
         if q_idx in demandas_por_indice.get(p, {}):
             demanda_q = demandas_por_indice[p][q_idx]
             m_q = semanas_por_cuartil_dict[q_idx]
             # Seleccionar ratios correctos
             ratios = ratio_demanda_semanal_anomalo if m_q == ANOMALOUS_QUARTILE_WEEKS else ratio_demanda_semanal_std
             num_ratios = len(ratios)
             # Verificar si el número de semanas coincide con los ratios esperados
             if m_q != len(ratios):
                  print(f"ADVERTENCIA: Mismatch semanas Q{q_idx} ({m_q}) y ratios ({len(ratios)}). Se usarán los {len(ratios)} ratios disponibles.")

             for s_local in range(1, m_q + 1):
                 ratio_idx = min(s_local - 1, num_ratios - 1)
                 ratio = ratios[ratio_idx]
                 if (q_idx, s_local) in semanas_cuartil_local_a_global:
                     t = semanas_cuartil_local_a_global[(q_idx, s_local)]
                     demandas_semanales[p][t] = demanda_q * ratio

# Calcular SST por cuartil global
sst_cuartil = defaultdict(dict) # {prod: {q_idx: sst_valor}}
for p in productos:
    for q_idx in quartiles_idx:
        siguiente_q_idx = q_idx + 1
        sst_calculado = 0
        # Calcular SST si existe el siguiente cuartil y sus datos
        if siguiente_q_idx in semanas_por_cuartil_dict and siguiente_q_idx in demandas_por_indice.get(p, {}):
            demanda_siguiente = demandas_por_indice[p][siguiente_q_idx]
            semanas_siguiente = semanas_por_cuartil_dict[siguiente_q_idx]
            if semanas_siguiente > 0: # Evitar división por cero
                sst_calculado = (demanda_siguiente / semanas_siguiente) * sstw_por_producto[p]
        sst_cuartil[p][q_idx] = sst_calculado

print("Pre-cálculos globales completados.")

# Celda 5: Funciones de Ayuda

def estado_final_error(mensaje, solver_nm='N/A', estado_code=-99):
    """Crea un diccionario de estado de error estándar."""
    return {"estado": estado_code, "mensaje": mensaje, "solver_name": solver_nm}

# Puedes añadir otras funciones auxiliares aquí si las necesitas
print("Funciones de ayuda definidas.")

# Función principal de resolución por segmento (`resolver_segmento_lgp_mip`), esto nos ayuda a reducir el tiempo de ejecución

def resolver_segmento_lgp_mip(
    #Identificación del segmento
    id_segmento, # String o número para identificar esta ejecución
    quartiles_a_resolver, # Lista de índices numéricos [q1, q2, q3, q4] o menos
    segmento_inventarios_iniciales, # Dict {prod: valor} T_{i, t_start-1}
    segmento_wafers_iniciales_t0, # Dict {prod: valor} w_{i, t_start-1} (para ramp-up)
    #Datos y mapeos Globales (precalculados)
    productos,
    semanas_cuartil_local_a_global,
    semana_global_a_cuartil_local,
    semanas_por_cuartil_dict,
    demandas_semanales,
    densidad_por_producto,
    porcentaje_rendimiento_por_producto,
    sst_cuartil,
    capacidad_obleas_por_semana,
    #Parámetros del modelo
    RUpMax, TE_min, TE_max, FINAL_TE_TARGET_MODE, Wmin_s,
    #configuración del solver
    solver_name, time_limit_seconds, mip_gap_relative, solver_threads
):
    """
    Resuelve el modelo LGP para un segmento específico de cuartiles.

    Retorna:
        - resultados_segmento (dict): Resultados detallados del segmento.
        - final_inventarios (dict): Inventario final {prod: valor} al final del segmento.
        - final_wafers (dict): Obleas finales {prod: valor} (si ramp-up activo).
        - estado_final (dict): Estado de la solución del segmento.
    """
    start_time_segmento = time.time()
    print(f"\n--- Resolviendo Segmento {id_segmento} (Quartiles: {quartiles_a_resolver}) ---")

    #Determinar rango de semanas globales para este segmento
    t_start = float('inf')
    t_end = float('-inf')
    if not quartiles_a_resolver: # Check for empty list
        print(f"Error: Lista de cuartiles vacía para el segmento {id_segmento}.")
        return None, None, None, estado_final_error(f"Segmento {id_segmento}: Lista de cuartiles vacía", solver_name)

    for q_idx in quartiles_a_resolver:
        m_q = semanas_por_cuartil_dict.get(q_idx, 0) # Usar get con default 0
        if m_q == 0:
             print(f"Advertencia: Cuartil {q_idx} tiene 0 semanas en semanas_por_cuartil_dict.")
             continue
        for s_local in range(1, m_q + 1):
             if (q_idx, s_local) in semanas_cuartil_local_a_global:
                  t_global = semanas_cuartil_local_a_global[(q_idx, s_local)]
                  t_start = min(t_start, t_global)
                  t_end = max(t_end, t_global)

    if t_start > t_end: # Si no se encontraron semanas mapeadas
        print(f"Error: No se encontraron semanas válidas mapeadas para los cuartiles {quartiles_a_resolver}.")
        return None, None, None, estado_final_error(f"Segmento {id_segmento}: Sin semanas válidas mapeadas", solver_name)

    #Índices para este segmento (usando tiempo global)
    tiempo = list(range(t_start, t_end + 1))
    W_segmento_horizonte = len(tiempo)
    producto_tiempo = [(p, t) for p in productos for t in tiempo]
    print(f"Segmento abarca semanas globales: {t_start} a {t_end} ({W_segmento_horizonte} semanas)")

    #Crear el modelo para este segmento
    modelo = plp.LpProblem(f"Planificacion_LGP_MIP_Segmento_{id_segmento}", plp.LpMinimize)

    # Declaramos las variables de decisión y auxiliares
    k = plp.LpVariable.dicts("Lotes", producto_tiempo, lowBound=0, cat=plp.LpInteger)
    T = plp.LpVariable.dicts("Inventario", producto_tiempo, cat=plp.LpContinuous)
    d_T_neg = plp.LpVariable.dicts("Deficit_Inv", producto_tiempo, lowBound=0, cat=plp.LpContinuous)
    # Definir desviaciones TE solo para los cuartiles de este segmento
    d_TE_neg = plp.LpVariable.dicts("Deficit_TE", quartiles_a_resolver, lowBound=0, cat=plp.LpContinuous)
    d_TE_pos = plp.LpVariable.dicts("Exceso_TE", quartiles_a_resolver, lowBound=0, cat=plp.LpContinuous)

    #Restricciones
    # 1. Balance de Inventario Semanal
    for p in productos:
        for t in tiempo:
            T_anterior = segmento_inventarios_iniciales.get(p, 0) if t == t_start else T[(p, t - 1)] # Usar get con default 0
            rendimiento_idx = min(t - 1, len(porcentaje_rendimiento_por_producto[p]) - 1)
            rendimiento = porcentaje_rendimiento_por_producto[p][rendimiento_idx] / 100.0
            produccion = densidad_por_producto[p] * (5 * k[(p, t)]) * rendimiento
            demanda = demandas_semanales.get(p, {}).get(t, 0)
            modelo += T[(p, t)] == T_anterior + produccion - demanda, f"BalanceInv_{p}_{t}"

    # 2. Capacidad Total de obleas y mínimo semanal
    for t in tiempo:
        capacidad_idx = min(t - 1, len(capacidad_obleas_por_semana) - 1)
        capacidad = capacidad_obleas_por_semana[capacidad_idx]
        modelo += plp.lpSum(5 * k[(p, t)] for p in productos) <= capacidad, f"Capacidad_{t}"
        modelo += plp.lpSum(5 * k[(p, t)] for p in productos) >= Wmin_s, f"MinObleas_{t}"

    # 3. Definición de TE
    TE = {}
    for q_idx in quartiles_a_resolver:
         t_final_cuartil_segmento = -1
         m_q = semanas_por_cuartil_dict.get(q_idx, 0)
         if m_q == 0: continue # Saltar si el cuartil no tiene semanas

         temp_t_final_q = -1
         for s_local_rev in range(m_q, 0, -1):
             if (q_idx, s_local_rev) in semanas_cuartil_local_a_global:
                 temp_t_final_q = semanas_cuartil_local_a_global[(q_idx, s_local_rev)]
                 break

         if temp_t_final_q != -1 and t_start <= temp_t_final_q <= t_end:
             t_final_cuartil_segmento = temp_t_final_q
             # Verificar si T existe para esa semana final antes de crear TE
             if all((p, t_final_cuartil_segmento) in T for p in productos):
                TE[q_idx] = plp.LpVariable(f"TE_Cuartil_{q_idx}", cat=plp.LpContinuous)
                sum_T_final = plp.lpSum(T.get((p, t_final_cuartil_segmento), 0) for p in productos)
                sum_SST = plp.lpSum(sst_cuartil.get(p, {}).get(q_idx, 0) for p in productos)
                modelo += TE[q_idx] == sum_T_final - sum_SST, f"DefineTE_{q_idx}"
             else:
                 # Esto puede ocurrir si t_final_cuartil_segmento es t_start-1 (no debería)
                 print(f"Advertencia: No se pudo definir TE para Q{q_idx} en segmento {id_segmento}. T[{t_final_cuartil_segmento}] no existe.")

    #Restricciones de metas-------------------------------------
    for p, t in producto_tiempo:
        modelo += T[(p, t)] + d_T_neg[(p, t)] >= 0, f"MetaInvMin_{p}_{t}"

    ultimo_q_global_idx = max(quartiles_idx) if quartiles_idx else -1
    es_ultimo_cuartil_global = ultimo_q_global_idx in quartiles_a_resolver

    for q_idx in quartiles_a_resolver:
         if q_idx in TE: # Solo si TE[q_idx] fue definido
             if es_ultimo_cuartil_global and q_idx == ultimo_q_global_idx:
                 # --- Lógica Meta TE Final (sin cambios) ---
                 if FINAL_TE_TARGET_MODE == 'zero':
                     print(f"Segmento {id_segmento}: Configurando Meta TE final (Q{q_idx}) = 0")
                     modelo += TE[q_idx] + d_TE_neg[q_idx] - d_TE_pos[q_idx] == 0, f"MetaTEfinal_Eq0_{q_idx}"
                 elif FINAL_TE_TARGET_MODE == 'range':
                     print(f"Segmento {id_segmento}: Configurando Meta TE final (Q{q_idx}) en rango [{TE_min}, {TE_max}]")
                     modelo += TE[q_idx] + d_TE_neg[q_idx] >= TE_min, f"MetaTEfinal_Min_{q_idx}"
                     modelo += TE[q_idx] - d_TE_pos[q_idx] <= TE_max, f"MetaTEfinal_Max_{q_idx}"
                 else: # Tratar como intermedio si modo no reconocido
                      modelo += TE[q_idx] + d_TE_neg[q_idx] >= TE_min, f"MetaTEmin_{q_idx}"
                      modelo += TE[q_idx] - d_TE_pos[q_idx] <= TE_max, f"MetaTEmax_{q_idx}"
             else: # Metas TE intermedias el TE debe d eestar entre 70 y 140 millones
                 modelo += TE[q_idx] + d_TE_neg[q_idx] >= TE_min, f"MetaTEmin_{q_idx}"
                 modelo += TE[q_idx] - d_TE_pos[q_idx] <= TE_max, f"MetaTEmax_{q_idx}"

    #Configuración del solver
    solver_instance = None
    # Bloque selección solver: CBC, GLPK, SCIP - igual que antes
    if solver_name.upper() == 'CBC':
        opts = {"msg": True, "timeLimit": time_limit_seconds, "gapRel": mip_gap_relative}
        if solver_threads > 0: opts["threads"] = solver_threads
        try: solver_instance = plp.PULP_CBC_CMD(**opts)
        except Exception as e:
             print(f"Warn: Fallback CBC simple. Error: {e}")
             solver_instance = plp.PULP_CBC_CMD(msg=True, timeLimit=time_limit_seconds)
    elif solver_name.upper() == 'GLPK':
        opts_list = ['--tmlim', str(time_limit_seconds), '--mipgap', str(mip_gap_relative)]
        try:
            solver_instance = plp.GLPK_CMD(msg=True, mip=True, options=opts_list)
            if not solver_instance.available(): raise RuntimeError("GLPK no disponible")
        except Exception as e: print(f"Error GLPK: {e}"); return None, None, None, estado_final_error(f"Segmento {id_segmento}: GLPK no disponible o error config.", solver_name)
    elif solver_name.upper() == 'SCIP':
         try:
             solver_instance = plp.SCIP_CMD(msg=True, timeLimit=time_limit_seconds, gapRel=mip_gap_relative)
             if not solver_instance.available(): raise RuntimeError("SCIP no disponible")
         except Exception as e: print(f"Error SCIP: {e}"); return None, None, None, estado_final_error(f"Segmento {id_segmento}: SCIP no disponible o error config.", solver_name)
    #Añadir otros solvers si se usan
    else:
        print(f"Error: Solver '{solver_name}' no es una opción válida reconocida.")
        return None, None, None, estado_final_error(f"Solver '{solver_name}' no válido.", solver_name)

    if solver_instance is None: # Si falló la creación por alguna razón
        print("Error: No se pudo crear la instancia del solver.")
        return None, None, None, estado_final_error("Fallo al crear instancia del solver.", solver_name)

    #Resolución Lexicográfica
    estado_final = {"estado": plp.LpStatusNotSolved, "mensaje": "Resolución LGP no iniciada", "solver_name": solver_name}
    objetivos_alcanzados = {}
    lp_dir = f"lp_models/segmento_{id_segmento}"
    os.makedirs(lp_dir, exist_ok=True)

    #Función interna resolver_meta_paso_segmento
    def resolver_meta_paso_segmento(objetivo, nombre_meta, numero_meta):
        nonlocal estado_final, modelo, solver_instance # Permitir modificar estado_final
        print(f"-- Resolviendo Meta {numero_meta}: {nombre_meta} (Segmento {id_segmento}) --")
        start_time_meta = time.time()
        modelo.setObjective(objetivo)
        lp_filename = f"{lp_dir}/modelo_{solver_name}_antes_meta_{numero_meta}.lp"
        try: modelo.writeLP(lp_filename)
        except Exception as e_lp: print(f"Advertencia: No se pudo guardar {lp_filename}: {e_lp}")

        status = -99 # Código de error inicial
        try:
            status = modelo.solve(solver_instance)
        except Exception as e:
            print(f"Excepción durante solve() para Meta {numero_meta}: {e}")
            estado_final = estado_final_error(f"Excepción en solver Meta {numero_meta}: {e}", solver_name, -99)
            return False, None

        solve_time = time.time() - start_time_meta
        status_text = plp.LpStatus.get(status, f"Código Desconocido ({status})")
        print(f"Estado Meta {numero_meta} (Seg {id_segmento}, {solver_name}): {status_text} ({solve_time:.2f}s)")

        # Lógica de manejo de estados (Optimal, Not Solved, Infeasible, etc.)
        if status in [plp.LpStatusOptimal, plp.LpStatusNotSolved]: # Tratar Not Solved como potencialmente válido
            if status == plp.LpStatusNotSolved:
                 print(f"Advertencia: Solver terminó con estado 'Not Solved'. Intentando usar solución actual.")
            try:
                valor_obj = plp.value(objetivo) if objetivo is not None else 0
                if valor_obj is None: # Si no se puede obtener valor (común en Not Solved)
                     print(f"Advertencia: No se pudo obtener valor para Meta {numero_meta} (estado {status_text}). No se fijará restricción.")
                     # Actualizar estado final pero permitir continuar si no es infactible
                     estado_final = {"estado": status, "mensaje": f"Meta {numero_meta} ({status_text}), sin valor obj.", "solver_name": solver_name}
                     return True, None # Éxito parcial (continuar LGP)
                else:
                    print(f"Valor Meta {numero_meta} (Seg {id_segmento}): {valor_obj:,.2f}")
                    if objetivo is not None:
                        modelo += objetivo <= valor_obj + 1e-6, f"FijarMeta_{numero_meta}" # Tol num.
                    estado_final = {"estado": status, "mensaje": f"Meta {numero_meta} resuelta ({status_text})", "solver_name": solver_name}
                    return True, valor_obj
            except Exception as e_post:
                 print(f"Error post-procesando Meta {numero_meta} (estado {status_text}): {e_post}")
                 estado_final = {"estado": status, "mensaje": f"Meta {numero_meta} ({status_text}), error post-proc: {e_post}", "solver_name": solver_name}
                 return True, None # Éxito parcial para intentar seguir

        elif status == plp.LpStatusInfeasible:
             msg_err = f"Modelo INFACTIBLE en Meta {numero_meta} ({nombre_meta}) (Seg {id_segmento}) con {solver_name}."
             lp_infeasible = f"{lp_dir}/modelo_{solver_name}_infeasible_meta_{numero_meta}.lp"
             try: modelo.writeLP(lp_infeasible); msg_err += f" Modelo guardado en {lp_infeasible}"
             except Exception as e_lp: msg_err += f" No se pudo guardar modelo infactible: {e_lp}"
             estado_final = estado_final_error(msg_err, solver_name, status)
             return False, None # Fallo LGP -> Detener segmento

        else: # Unbounded, Undefined, Error, etc.
             msg_err = f"Estado inesperado {status_text} en Meta {numero_meta} ({nombre_meta}) (Seg {id_segmento}) con {solver_name}."
             estado_final = estado_final_error(msg_err, solver_name, status)
             return False, None # Fallo LGP -> Detener segmento


    # Resolver Metas ---
    # Meta 1 que es cumplir primeo la demnad del primer producto
    P1 = plp.lpSum(d_T_neg.get((p, t), 0) for p, t in producto_tiempo if p == '21A')
    success, val = resolver_meta_paso_segmento(P1, "Min Déficit 21A", 1)
    if not success: return None, None, None, estado_final # Detener si falla una meta crucial
    objetivos_alcanzados['P1'] = val
    # Meta 2 que es cumplir la demanada del segundo producto
    P2 = plp.lpSum(d_T_neg.get((p, t), 0) for p, t in producto_tiempo if p == '22B')
    success, val = resolver_meta_paso_segmento(P2, "Min Déficit 22B", 2)
    if not success: return None, None, None, estado_final
    objetivos_alcanzados['P2'] = val
    # Meta 3 que es cumplir la demanada del tercer producto
    P3 = plp.lpSum(d_T_neg.get((p, t), 0) for p, t in producto_tiempo if p == '23C')
    success, val = resolver_meta_paso_segmento(P3, "Min Déficit 23C", 3)
    if not success: return None, None, None, estado_final
    objetivos_alcanzados['P3'] = val
    # Meta 4
    if TE: # Solo si hay TEs definidos
        P4 = plp.lpSum(d_TE_neg.get(q, 0) + d_TE_pos.get(q, 0) for q in quartiles_a_resolver if q in TE)
        success, val = resolver_meta_paso_segmento(P4, "Min Desviaciones TE", 4)
        objetivos_alcanzados['P4'] = val
        if not success and estado_final.get('estado') != plp.LpStatusInfeasible:
             print(f"Advertencia: Meta 4 (Desviaciones TE) no optimizada completamente en Segmento {id_segmento}.")
             # No detener, solo registrar advertencia
    else:
        print(f"INFO: Omitiendo Meta 4 en Segmento {id_segmento} (sin variables TE definidas).")
        objetivos_alcanzados['P4'] = 0 # O None

    #Extracción de resultados
    resultados_segmento = {
        'id_segmento': id_segmento, 'quartiles': quartiles_a_resolver,
        't_start': t_start, 't_end': t_end,
        'k': {}, 'T': {}, 'TE': {}, 'd_T_neg': {}, 'd_TE_neg': {}, 'd_TE_pos': {},
        'estado_final_segmento': estado_final, # El estado final del LGP
        'objetivos_alcanzados_segmento': objetivos_alcanzados,
        'tiempo_segmento': time.time() - start_time_segmento
    }
    final_inventarios = {}
    final_wafers = {} # Para ramp-up

    # Extraer valores solo si el estado final NO es infeasible o error grave
    ultimo_estado_valido = estado_final.get('estado', -99)
    if ultimo_estado_valido not in [plp.LpStatusInfeasible, plp.LpStatusUndefined, -99]:
        def safe_value(var_dict, key, default=0):
             # Función safe_value idéntica
             var = var_dict.get(key)
             if var is None: return default
             try:
                 val = var.value()
                 return val if val is not None else default
             except AttributeError: return default
             except Exception: return default

        # Extraer k, T, d_T_neg
        for p, t in producto_tiempo:
            resultados_segmento['k'][(p, t)] = safe_value(k, (p,t))
            resultados_segmento['T'][(p, t)] = safe_value(T, (p,t))
            resultados_segmento['d_T_neg'][(p, t)] = safe_value(d_T_neg, (p,t))
            # Capturar estado final para la siguiente iteración en t_end
            if t == t_end:
                 final_inventarios[p] = resultados_segmento['T'][(p, t)]
                 # if ramp_up_activo: final_wafers[p] = 5 * resultados_segmento['k'][(p, t)]

        # Extraer TE y sus desviaciones (si existen)
        for q in quartiles_a_resolver:
             resultados_segmento['TE'][q] = safe_value(TE, q, default=None) # None si no definido
             resultados_segmento['d_TE_neg'][q] = safe_value(d_TE_neg, q)
             resultados_segmento['d_TE_pos'][q] = safe_value(d_TE_pos, q)

        # Verificación final de inventarios
        if len(final_inventarios) != len(productos):
             print(f"Advertencia: Faltan inventarios finales en segmento {id_segmento}. Rellenando con 0.")
             for p in productos:
                  final_inventarios.setdefault(p, 0) # Usar setdefault

    else: #Estado Infeasible o Error grave
        print(f"ERROR: Segmento {id_segmento} terminó con estado {plp.LpStatus.get(ultimo_estado_valido, 'Desconocido')}. No se pueden obtener resultados ni inventarios finales.")
        final_inventarios = None # Indicar fallo irrecuperable
        final_wafers = None

    print(f"--- Fin Segmento {id_segmento} ({resultados_segmento['tiempo_segmento']:.2f}s) ---")
    # Devolver siempre resultados (aunque estén vacíos si falló) y el estado final
    return resultados_segmento, final_inventarios, final_wafers, estado_final

print("Función 'resolver_segmento_lgp_mip' definida.")

# Función de orquestación iterativa (con Grupos Dinámicos)

def run_iterative_lgp(
    # ---Argumentos (igual que antes
    productos, quartiles_idx,
    semanas_cuartil_local_a_global, semana_global_a_cuartil_local, semanas_por_cuartil_dict,
    demandas_semanales, densidad_por_producto, porcentaje_rendimiento_por_producto,
    sst_cuartil, capacidad_obleas_por_semana,
    inventarios_iniciales_globales, wafers_iniciales_t0_globales,
    RUpMax, TE_min, TE_max, FINAL_TE_TARGET_MODE, Wmin_s,
    solver_name, time_limit_seconds, mip_gap_relative, solver_threads,
    # Añadir parámetro para semanas estándar
    standard_weeks=STANDARD_WEEKS_PER_QUARTILE
):
    """
    Orquesta la ejecución iterativa del LGP, formando grupos dinámicos.
    Intenta formar grupos de 4, pero reduce a 3 si el 4to cuartil potencial
    tiene un número de semanas diferente al estándar.
    """
    print("\n" + "="*30 + " Iniciando Ejecución Iterativa LGP (Grupos Dinámicos) " + "="*30)
    start_time_iterative = time.time()

    all_segment_results = []
    current_inventarios_iniciales = inventarios_iniciales_globales.copy()
    current_wafers_iniciales_t0 = wafers_iniciales_t0_globales.copy()

    num_quartiles = len(quartiles_idx)
    estado_general = "Exitoso"
    i = 0 # Índice del primer cuartil del *próximo* segmento

    # Bucle WHILE para manejar avance variable
    while i < num_quartiles:
        # Determinar tamaño del grupo para esta iteración es decir, cuantos cuartiles se abarcan
        default_group_size = 4
        grupo_size = default_group_size

        # Calcular índice (global) del último cuartil en un grupo potencial de 4
        potential_end_idx_global = min(i + default_group_size - 1, num_quartiles - 1)

        # Verificar si podemos formar un grupo y aplicar la regla
        if potential_end_idx_global >= i:
            last_q_idx_in_potential_group = quartiles_idx[potential_end_idx_global]
            num_semanas_last_q = semanas_por_cuartil_dict.get(last_q_idx_in_potential_group, standard_weeks)

            # Aplicar la regla de anomalía
            if num_semanas_last_q != standard_weeks and potential_end_idx_global == (i + default_group_size - 1):
                 print(f"INFO: Último cuartil potencial Q{last_q_idx_in_potential_group} tiene {num_semanas_last_q} (!={standard_weeks}) semanas.")
                 print(f"      Reduciendo tamaño del grupo actual (iniciando en índice {i}) a 3.")
                 grupo_size = 3

        # Construir el segmento real de cuartiles
        quartiles_para_este_segmento = []
        segment_id_parts = []
        actual_segment_len = 0
        for j in range(grupo_size):
            current_idx = i + j
            if current_idx < num_quartiles:
                q_idx = quartiles_idx[current_idx]
                quartiles_para_este_segmento.append(q_idx)
                # Usar nombre del cuartil para el ID si está disponible
                q_name = q_idx_a_nombre.get(q_idx, f"Qidx{q_idx}")
                segment_id_parts.append(q_name)
                actual_segment_len += 1
            else:
                break

        if not quartiles_para_este_segmento:
            print(f"Advertencia: No se formó segmento en la iteración comenzando en índice {i}. Terminando.")
            break

        segment_id = "-".join(segment_id_parts)

        #Ahora debemos llamar al solver
        resultados_segmento, final_inventarios, final_wafers, estado_final_segmento = resolver_segmento_lgp_mip(
            segment_id, quartiles_para_este_segmento,
            current_inventarios_iniciales, current_wafers_iniciales_t0,
            # Pasar datos globales y parámetros
            productos, semanas_cuartil_local_a_global, semana_global_a_cuartil_local, semanas_por_cuartil_dict,
            demandas_semanales, densidad_por_producto, porcentaje_rendimiento_por_producto, sst_cuartil,
            capacidad_obleas_por_semana,
            RUpMax, TE_min, TE_max, FINAL_TE_TARGET_MODE, Wmin_s,
            solver_name, time_limit_seconds, mip_gap_relative, solver_threads
        )

        #Manejar resultados
        if resultados_segmento: # Guardar siempre si no es None
            all_segment_results.append(resultados_segmento)

        # Detener si hubo error crítico (Infeasible o no se pudo obtener inventario)
        if final_inventarios is None:
            print(f"\nERROR CRÍTICO: Segmento {segment_id} falló. Ejecución detenida.")
            estado_general = f"Fallo Crítico en Segmento {segment_id}: {estado_final_segmento.get('mensaje', 'Error desconocido')}"
            break

        # Actualizamos el estado
        current_inventarios_iniciales = final_inventarios
        # if final_wafers is not None: current_wafers_iniciales_t0 = final_wafers

        #Avanzar el índice
        i += actual_segment_len
        # print(f"Índice 'i' avanzado a: {i}")



    total_time_iterative = time.time() - start_time_iterative
    print("\n" + "="*30 + " Fin Ejecución Iterativa LGP (Grupos Dinámicos) " + "="*30)
    print(f"Estado General Final: {estado_general}")
    print(f"Tiempo Total Iterativo: {total_time_iterative:.2f} segundos")

    return all_segment_results, estado_general, total_time_iterative

print("Función 'run_iterative_lgp' (Grupos Dinámicos) definida.")

# Función para mostrar resultados agregados

def mostrar_resultados_agregados(
    all_segment_results, estado_general, tiempo_total,
    productos, semana_global_a_cuartil_local, capacidad_obleas_por_semana,
    densidad_por_producto, porcentaje_rendimiento_por_producto, quartiles_idx,
    # Añadir nombre para archivos de salida
    output_suffix="GruposDinamicos"
    ):
    """
    Muestra los resultados agregados de todos los segmentos procesados.
    Genera tablas y gráficos consolidados.
    """
    print("\n==================================================")
    print("====== ESTADO FINAL - EJECUCIÓN ITERATIVA ======")
    print("==================================================")
    print(f"Estado General Final: {estado_general}")
    print(f"Tiempo Total de Ejecución: {tiempo_total:.2f} segundos")
    if not all_segment_results:
        print("No hay resultados de segmentos para mostrar.")
        return

    #Resumen estado por segmento (conjunto de cuartiles)
    print("\nResumen estado por segmento (conjunto de cuartiles):")
    num_segmentos_exitosos = 0
    for res_seg in all_segment_results:
        if res_seg:
             id_seg = res_seg.get('id_segmento', 'Desconocido')
             estado_info = res_seg.get('estado_final_segmento', {})
             status_code = estado_info.get('estado', -99)
             mensaje = estado_info.get('mensaje', 'N/A')
             solver_used = estado_info.get('solver_name', 'N/A')
             tiempo_seg = res_seg.get('tiempo_segmento', 0)
             status_text = plp.LpStatus.get(status_code, f"Código Desconocido ({status_code})")
             print(f" - Segmento {id_seg}: {status_text} ({solver_used}, {tiempo_seg:.2f}s) - {mensaje}")
             if status_code not in [plp.LpStatusInfeasible, plp.LpStatusUndefined, -99]:
                 num_segmentos_exitosos += 1
        else: print(" - Error: Resultado de segmento inválido (None).")
    print(f"Total de segmentos procesados con éxito (parcial o total): {num_segmentos_exitosos}")

    #Agregar resultados semanales
    print("\n==== PLANIFICACIÓN SEMANAL AGREGADA (Iterativa) ====\n")
    all_plan_data = []
    max_t_global = 0
    min_t_global = float('inf')
    valid_segments_for_plan = 0

    for res_seg in all_segment_results:
         if not res_seg or res_seg.get('estado_final_segmento', {}).get('estado') in [plp.LpStatusInfeasible, plp.LpStatusUndefined, -99]:
             continue
         valid_segments_for_plan += 1
         t_start = res_seg['t_start']; t_end = res_seg['t_end']
         max_t_global = max(max_t_global, t_end); min_t_global = min(min_t_global, t_start)
         for t in range(t_start, t_end + 1):
             # Lógica interna de creación de fila idéntica
             q_idx, s_local = semana_global_a_cuartil_local.get(t, (-1, -1))
             fila = {'Semana Global': t, 'CuartilIdx': q_idx, 'SemanaLocal': s_local}
             w_total_semana = 0
             for p in productos:
                 key = (p, t)
                 k_val = res_seg.get('k', {}).get(key, 0) or 0
                 t_val = res_seg.get('T', {}).get(key, 0) or 0
                 d_t_neg_val = res_seg.get('d_T_neg', {}).get(key, 0) or 0
                 w_val = 5 * k_val
                 y_val = 0
                 try:
                     if k_val > 0:
                         rend_idx = min(t - 1, len(porcentaje_rendimiento_por_producto[p]) - 1)
                         rend = porcentaje_rendimiento_por_producto[p][rend_idx] / 100.0
                         y_val = densidad_por_producto[p] * w_val * rend
                 except Exception as e_ycalc: y_val = f'Error: {e_ycalc}'
                 fila[f'Lotes {p}'] = k_val; fila[f'Obleas {p}'] = w_val
                 fila[f'Prod {p}'] = y_val; fila[f'Inv {p}'] = t_val
                 fila[f'Deficit {p}'] = d_t_neg_val
                 w_total_semana += w_val
             fila['Obleas Totales'] = w_total_semana
             cap_idx = min(t - 1, len(capacidad_obleas_por_semana) - 1)
             fila['Capacidad'] = capacidad_obleas_por_semana[cap_idx]
             all_plan_data.append(fila)

    if not all_plan_data:
         print("No hay datos de planificación semanales válidos para mostrar.")
    else:
        # --- (Lógica de mostrar/guardar DataFrame semanal idéntica, usando output_suffix) ---
        print(f"Agregando datos de {valid_segments_for_plan} segmentos válidos.")
        df_plan_agregado = pd.DataFrame(all_plan_data).sort_values(by='Semana Global').reset_index(drop=True)
        pd.set_option('display.max_rows', 30); pd.set_option('display.max_columns', None)
        pd.set_option('display.width', 1000); pd.set_option('display.float_format', '{:,.1f}'.format)
        print(df_plan_agregado.head(15).to_string(index=False))
        if len(df_plan_agregado) > 30: print("...")
        print(df_plan_agregado.tail(15).to_string(index=False))
        try:
            csv_filename = f'planificacion_semanal_ITERATIVA_{output_suffix}_{SOLVER_NAME}.csv'
            df_plan_agregado.to_csv(csv_filename, index=False, float_format='%.2f')
            print(f"\nTabla agregada guardada en '{csv_filename}'")
        except Exception as e: print(f"\nAdvertencia: No se pudo guardar CSV agregado: {e}")

    # --- Agregar Resultados TE ---
    print("\n==== BALANCE DE INVENTARIO EN EXCESO (TE) POR CUARTIL (Agregado) ====\n")
    all_te_data = []
    valid_segments_for_te = 0
    for res_seg in all_segment_results:
         if not res_seg or res_seg.get('estado_final_segmento', {}).get('estado') in [plp.LpStatusInfeasible, plp.LpStatusUndefined, -99]: continue
         valid_segments_for_te += 1
         for q_idx in res_seg.get('quartiles', []):
             te_val = res_seg.get('TE', {}).get(q_idx, 'N/C')
             if te_val not in ['N/C', None]:
                  dneg_val = res_seg.get('d_TE_neg', {}).get(q_idx, 0)
                  dpos_val = res_seg.get('d_TE_pos', {}).get(q_idx, 0)
                  all_te_data.append({'CuartilIdx': q_idx, 'TE Calculado': te_val, 'd_TE_neg': dneg_val, 'd_TE_pos': dpos_val})

    if not all_te_data: print("No hay datos de TE válidos para mostrar.")
    else:
        # --- (Lógica de mostrar/guardar DataFrame TE idéntica, usando output_suffix) ---
        print(f"Agregando datos TE de {valid_segments_for_te} segmentos válidos.")
        df_te_agregado = pd.DataFrame(all_te_data)
        df_te_agregado = df_te_agregado.drop_duplicates(subset=['CuartilIdx'], keep='last').sort_values(by='CuartilIdx').reset_index(drop=True)
        pd.options.display.float_format = '{:,.1f}'.format
        print(df_te_agregado.to_string(index=False))
        try:
            csv_filename_te = f'balance_te_cuartil_ITERATIVA_{output_suffix}_{SOLVER_NAME}.csv'
            df_te_agregado.to_csv(csv_filename_te, index=False, float_format='%.2f')
            print(f"\nTabla TE agregada guardada en '{csv_filename_te}'")
        except Exception as e: print(f"\nAdvertencia: No se pudo guardar CSV de TE agregado: {e}")

    # --- Déficit Acumulado Total ---
    print("\n==== DÉFICIT ACUMULADO TOTAL POR PRODUCTO (Iterativa) ====\n")
    total_deficit = {p: 0 for p in productos}
    if 'df_plan_agregado' in locals() and not df_plan_agregado.empty:
        # --- (Lógica de cálculo déficit idéntica) ---
        for p in productos:
            deficit_col = f'Deficit {p}'
            if deficit_col in df_plan_agregado.columns:
                 total_deficit[p] = pd.to_numeric(df_plan_agregado[deficit_col], errors='coerce').fillna(0).sum()
            print(f"Déficit total {p}: {total_deficit[p]:,.0f}")
    else: print("No se pudo calcular el déficit acumulado.")

    # --- Gráficos Agregados ---
    print("\nGenerando gráficos agregados...")
    if 'df_plan_agregado' in locals() and not df_plan_agregado.empty and min_t_global <= max_t_global:
        try:
            #Lógica de generación de gráficos idéntica, usando output_suffix en título
            plt.style.use('seaborn-v0_8-whitegrid')
            fig, axes = plt.subplots(3, 1, figsize=(18, 15), sharex=True)
            ax1, ax2, ax3 = axes[0], axes[1], axes[2]
            df_plot = df_plan_agregado.set_index('Semana Global')

            #Para la grafica de las cantidad de las obleas
            w_cols = [f'Obleas {p}' for p in productos if f'Obleas {p}' in df_plot.columns]
            df_plot[w_cols].plot(kind='bar', stacked=True, ax=ax1, width=0.8)
            df_plot['Capacidad_num'] = pd.to_numeric(df_plot['Capacidad'], errors='coerce')
            ax1.plot(df_plot.index, df_plot['Capacidad_num'], color='red', linestyle='--', linewidth=1.5, label='Capacidad Semanal')
            ax1.set_ylabel('Obleas / Capacidad'); ax1.set_title(f'Asignación Semanal vs Capacidad (Iterativa {output_suffix}, {min_t_global}-{max_t_global}) - Solver: {SOLVER_NAME}')
            ax1.legend(loc='upper left', bbox_to_anchor=(1, 1)); ax1.ticklabel_format(style='sci', axis='y', scilimits=(0,0), useMathText=True)

            #Para graficar el inventario de los producto que tenemos
            t_cols = [f'Inv {p}' for p in productos if f'Inv {p}' in df_plot.columns]
            df_plot[t_cols].plot(ax=ax2, marker='.', linestyle='-', linewidth=1, ms=3)
            ax2.axhline(0, color='black', linestyle='--', linewidth=1.0, label='Nivel Cero')
            ax2.set_ylabel('Inventario'); ax2.set_title(f'Evolución del Inventario Semanal (Iterativa {output_suffix})')
            ax2.legend(loc='upper left', bbox_to_anchor=(1, 1)); ax2.ticklabel_format(style='sci', axis='y', scilimits=(0,0), useMathText=True)

            #Para graficar los diferentes deficcits de los prductos que tenemos
            d_neg_cols = [f'Deficit {p}' for p in productos if f'Deficit {p}' in df_plot.columns]
            df_plot[d_neg_cols].plot(ax=ax3, marker='.', linestyle='-', linewidth=1, ms=3)
            ax3.set_xlabel('Semana Global'); ax3.set_ylabel('Déficit'); ax3.set_title(f'Déficit Semanal (d_T_neg) (Iterativa {output_suffix})')
            ax3.legend(loc='upper left', bbox_to_anchor=(1, 1)); ax3.ticklabel_format(style='sci', axis='y', scilimits=(0,0), useMathText=True)
            total_weeks_plot = max_t_global - min_t_global + 1
            tick_frequency = max(1, total_weeks_plot // 20 if total_weeks_plot > 0 else 1)
            ax3.set_xticks(np.arange(min_t_global, max_t_global + 1, tick_frequency)); ax3.tick_params(axis='x', rotation=45)


            plt.tight_layout(rect=[0, 0, 0.9, 1])
            plot_filename = f'resultados_planificacion_graficos_ITERATIVA_{output_suffix}_{SOLVER_NAME}.png'
            plt.savefig(plot_filename, dpi=150)
            print(f"\nGráficos agregados guardados en '{plot_filename}'")
            plt.close(fig)
        except ImportError: print("\nAdvertencia: Matplotlib/Seaborn no instalados. No se generaron gráficos.")
        except Exception as e: print(f"\nError inesperado generando gráficos agregados: {e}"); import traceback; print(traceback.format_exc())
    else:
        print("No hay datos suficientes o válidos para generar gráficos agregados.")

print("Función 'mostrar_resultados_agregados' definida.")

# Bloque principal de ejecución "main"

def main():
    """Función principal para ejecutar el proceso iterativo y mostrar resultados."""
    print("+" + "-"*60 + "+")
    print("|" + " Ejecutando Modelo Planificación LGP - ITERATIVO (GRUPOS DINÁMICOS) ".center(60) + "|")
    print("+" + "-"*60 + "+")

    # Verificación de solver para python
    print("\nVerificando solvers disponibles para PuLP:")
    available_solvers = plp.listSolvers(onlyAvailable=True)
    print(available_solvers if available_solvers else "¡No se encontraron solvers disponibles para PuLP!")
    # Comprobar si el solver seleccionado está en la lista (insensible a mayúsculas/minúsculas)
    if not any(SOLVER_NAME.upper() == s.upper() for s in available_solvers):
         print(f"ADVERTENCIA: El solver seleccionado '{SOLVER_NAME}' no parece estar disponible en la lista anterior.")
    print("-" * 62)

    #Mostrar configuración clave del modeo, ercrdando que originalmente deben sacr los datos de un excel
    print(f"Solver a usar: {SOLVER_NAME}") #nombre del solver que se va a utilizar
    print(f"Límite de tiempo por meta/segmento: {SOLVER_TIME_LIMIT_SECONDS_PER_GOAL}s")
    print(f"Gap Relativo MIP: {SOLVER_MIP_GAP_RELATIVE}")
    print(f"Hilos CPU Solver: {'Default' if SOLVER_THREADS <= 0 else SOLVER_THREADS}")
    print(f"Modo Meta TE Final: {FINAL_TE_TARGET_MODE}")
    print(f"Semanas estándar por cuartil: {STANDARD_WEEKS_PER_QUARTILE}")
    print("-" * 62)

    #Ejecutar el proceso iterativo que es basicamente hacer varias iteraciones para que no se tarde mucho el modelo

    # Asegurarse que todas las variables globales necesarias estén definidas
    # (productos, quartiles_idx, mapeos, datos semanales, parámetros, etc.)
    all_segment_results, estado_general, tiempo_total_iterativo = run_iterative_lgp(
        productos, quartiles_idx,
        semanas_cuartil_local_a_global, semana_global_a_cuartil_local, semanas_por_cuartil_dict,
        demandas_semanales, densidad_por_producto, porcentaje_rendimiento_por_producto,
        sst_cuartil, capacidad_obleas_por_semana,
        inventarios_iniciales_globales, wafers_iniciales_t0_globales,
        RUpMax, TE_min, TE_max, FINAL_TE_TARGET_MODE, Wmin_s,
        SOLVER_NAME, SOLVER_TIME_LIMIT_SECONDS_PER_GOAL, SOLVER_MIP_GAP_RELATIVE, SOLVER_THREADS,
        standard_weeks=STANDARD_WEEKS_PER_QUARTILE # Pasar explícitamente
    )

    #Mostrar resultados agregados
    mostrar_resultados_agregados(
        all_segment_results, estado_general, tiempo_total_iterativo,
        productos, semana_global_a_cuartil_local, capacidad_obleas_por_semana,
        densidad_por_producto, porcentaje_rendimiento_por_producto, quartiles_idx,
        output_suffix="GruposDinamicos" # Sufijo para nombres de archivo
    )

    print("\n" + "="*30 + " Fin del Script Iterativo (Grupos Dinámicos) " + "="*30)

# Ejecutar la función principal
if __name__ == "__main__":
    # Este bloque ahora solo llama a main()
    # La verificación de solvers y la hora se movieron dentro de main() o al inicio
    main()
elif __name__ == 'builtins': # Detecta ejecución en entorno interactivo como Jupyter
     print("\nINFO: Ejecutando en entorno interactivo (Jupyter?).")
     print("Para ejecutar el modelo completo, llama a la función 'main()' en una celda.")